if(typeof window==="undefined"){const RGB_COLOR_RANGE=255;const rgbToHsv=(red,green,blue)=>{const degMultiplier=60;const greenRotation=2;const blueRotation=4;const r=red/RGB_COLOR_RANGE;const g=green/RGB_COLOR_RANGE;const b=blue/RGB_COLOR_RANGE;const minColor=Math.min(r,g,b);const V=Math.max(r,g,b);const C=V-minColor;let H;if(C===0)H=0;else{if(V===r)H=degMultiplier*((g-b)/C);if(V===g)H=degMultiplier*(greenRotation+(b-r)/C);if(V===b)H=degMultiplier*(blueRotation+(r-g)/C);}
const S=V===0?0:C/V;return{H,S,V};};const chromaKeyOut=(red,green,blue,data)=>{const{key,channel,threshold,hueThreshold,valThreshold,satThreshold,}=data;if(channel==="colorKey"){const{H,S,V}=rgbToHsv(red,green,blue);if(Math.abs(key.H-H)>=hueThreshold)return false;if(Math.abs(key.S-S)>=satThreshold)return false;if(Math.abs(key.V-V)>=valThreshold)return false;return true;}
const channelValue=channel==="green"?green:blue;const otherChannels=channel==="green"?[red,blue]:[red,green];const max=Math.max(red,green,blue);if(max!==channelValue)return false;const mid=Math.max(...otherChannels);return max-mid>RGB_COLOR_RANGE-threshold;};onmessage=async function(e){const pixels=e.data.pixels.data;for(let p=0;p<pixels.length;p+=4){if(chromaKeyOut(pixels[p],pixels[p+1],pixels[p+2],e.data)){pixels[p+3]=0;}}
postMessage({pixels:e.data.pixels,});};}